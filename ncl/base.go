package ncl

/*
NCL - Null Convention Logic, с троичной базой. Суть такова, помимо основых входов выходов имеется дополнительный сигнал валидности, его истинность означает, что на соотв. выходе результат верный. Для примера, есть сумматор, два входа, один выход, если на входе А валидный сигнал, а на Б невалидный сигнал, то на выходе сумматора будет невалидный сигнал. Эта невалидность будет подана на вход следующего элемента и т.д. То есть, элементы отработают только тогда, когда для них готовы данные на входе.

Моделирование происходит на основе передачи значений от объектов-выходов через объекты-точки соединения к объектам-входам. В основе каждого объекта лежит горутина, а взаимодействие идет через каналы, то есть, у элементов нет общего тактового генератора. Таким образом каждый вход элемента представляет собой реализацию операции асинхронной логики - венъюнкция. Переключение сигнала данных происходит на фоне неизменности сигнала валидации.

Все элементы расположены на макетной плате с набором точек. Макетная плата в свою очередь тоже является элементом, таким образом реализуется компонентность модели. К точкам припаиваются входы и выходы. Ток идет от выходов к входам, при этом короткое замыкание охраняется для каждой точки, то есть, невозможно подать в одну точку разные сигналы. В идеале, должен присутсвовать только один валидный сигнал из набора входов.

В силу итеративной природы программ, невозможно непрерывное отслеживание значения переменной. Отсюда имеем вероятность пропуска валидного значения, однако, на плате в реальном проекте всегда присутствуют постоянно валидные источники сигнала - пины питания и триггеры-ячейки памяти, и вся схема зависит от их состояния, и не может произвольно это состояние сменить.
*/
import (
	"sim3/tri"
)

type PinCode int

const (
	I PinCode = iota
	O
	D
	S
	A
	B
	T
	N
	F
	C
)

type Pin interface {
}

type In interface {
	Pin
	Select() (bool, tri.Trit)
}

type Out interface {
	Pin
	Validate(bool, ...tri.Trit)
}

type Point interface {
	Solder(...Pin)
}

type Element interface {
	Pin(PinCode) Pin
}

type Compound interface {
	Element
	Point(string) Point
	InnerPin(PinCode) Pin
}
